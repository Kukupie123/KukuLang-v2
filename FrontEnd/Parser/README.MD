# KukuLang Parser
Parser is probably the most complicated piece of code to write in frontend section. <br>
A parsers job is to iterate the tokens generated by Lexer and turn them into valid statements or expressions that makes sense syntax wise and grammer wise. <br>
You would need to generally have to generate an AST or Parse tree followed by a semantic analysis to make sure that the code makes sense but in my case this was not necessary (as far as I have noticed). <br>

## Statements and expressions
Statements are instructions.
```
set a to 12;
```
Expressions are statements but they have a return value (In my case we sometimes may not have a return value);
```
set human's age to 12;
```
Here, ```human's age``` is an expression as it returns a reference to age variable of human. <br>
Another example would be
```
set a to 12+2*1;
```
Here, ```a``` and ```12+2*1``` would be an expression.

## Scopes
We also have scopes which is used for defining scope level tasks, types, variables and memory management. A scope is a class which can hold all the custom types and tasks defined in that scope, variables created in that scope and a reference to it's parent. <br>
It also has functions to create/update variables in the current scope or parent scope and to access defined tasks or types in current or parent scopes.



## Parsing Algorithms
There are several algorithms that have its own strength and weaknesses. One of the most common algorithm is probably going to be **Recursive Descent Parser (RDP)** which is quite simple to understand but it can get very dirty and confusing because of all the recursions. <br>
I initially started off with RDP but noticed that my code was getting too complicated, especially when dealing with expressions. I researched a little bit and caught an algorithm in the wild known as **Pratt Parser Algorithm (PP)**. It took me some time to grasp the concept of Pratt Parser and I still sometimes feel like I do not know it well. But I have been able to write it from scratch based on my understanding and also extended it's functionality beyond mathematical expressions so I think I some what have decent idea. PP is an amazing algorithm which makes working with expressions very clean and easy. It uses Precedence (Priority) to determine arrangement of an expression. <br> <br>

In the end I decided to create my own simple statement evaluator which takes some element of RDP for parsing statements, <br>
Pratt Parser for evaluating Expressions.

### Simple Statement Evaluator
This evaluator reads the token and determines what kind of statemnt it is dealing it. The type of evaluations we have are :- <br>
- Define Evaluator (Defining Custom Types and Tasks)
- Set Evaluator (evaluate Set statements)
- Function Call evaluator (Evaluate independent function calls)
- If evaluator (conditional if else evaluation)
- Return Evaluator (return statement evaluation)
- Loop evaluator (Evaluates loop)
- Print Evaluator (evaluates print statements)
```c#
public static void EvaluateToken<ParserReturnType, ParserArgument>(ParserBase<ParserReturnType, ParserArgument> parser, ASTScope scope)
        {
            //Each sub-evaluate method needs to process the whole statement upto its ending token such as "."
            switch (parser.CurrentToken.Type)
            {
                case TokenType.Define:
                    EvaluateDefineToken(parser, scope);
                    break;
                case TokenType.Set:
                    EvaluateSetToken(parser, scope);
                    break;
                case TokenType.Identifier:
                    EvaluateFunctionCall(parser, scope);
                    break;
                case TokenType.If:
                    EvaluateIfToken(parser, scope);
                    break;
                case TokenType.Return:
                    EvaluateReturnToken(parser, scope);
                    break;
                case TokenType.Until:
                    EvaluateLoopToken(parser, scope);
                    break;
                case TokenType.AsLongAs:
                    EvaluateLoopToken(parser, scope);
                    break;
                case TokenType.Print:
                    EvaluatePrint(parser, scope);
                    break;
                default:
                    throw new UnknownTokenException(parser.CurrentToken);
            }
        }
```
#### Define Evaluator
Example of define statements
```
Define Human with age(int);
Define Square returning float with num(int){
    return num*num;
}
```
Its grammatical structure is <br>
"Define" identifier with properties/arguments. <br>
```pseudo
if currentToken == returning {
    //it is a task definition

    //note down its return type
    //validate if the type exist in current or parent scope
    //int float text char bool exist by default
    //proceed to with and then store all the arguments
    //Create it's CustomTask Object and store it in scope's definedTask variable
}
else if currentToken == with{
    //it is custom type definition

    //proceed to with and store all of its properties while validate it's type
    //Create CustomType and store it in scope's definedType variable
}
```
#### Set evaluator
Example of set statements
```
set a to 12; ~simple~
set a's b's c to foo's bar; ~nested variable~
set b to Square with num(2); ~simple b, function call~
```
It's grammatical structure is <br>
"set" single/nestedVariable to expressionStatement; <br>
single/nestedVariable and expressionStatement are both handled by pratt parser.<br> <br>
Not gonna go into detail for the rest of the evaluator, look at the source code instead.

### Pratt Parser
Pratt parser is a parsing algorithm that looks simple enough but it's working can be quite tricky to understand.
The way it works is by defining Precedence levels for different operators such as 
```
private static readonly Dictionary<string, int> Precedence = new()
    {
        {"Lowest", 1},
        {"Comparison", 2},
        {"Sum", 3},
        {"Product", 4},
        {"BooleanOr", 5},
        {"BooleanAnd", 6}
    };
```
Next, we create a parse function that takes in precedent as its argument which is 1 by default. <br>
This function calls ```var left = ProcessPrimaryExpAndAdvance();``` and then enters a while loop where it keeps updating the left variable by nesting it with higher value expressions until it meets an operator with same or lower precedence.
```
public override ExpressionStmt Parse(int precedence = 1)
{
        var left = ProcessPrimaryExpAndAdvance();
        while (precedence < GetPrecedence(CurrentToken.Type))
        {
            // Intentionally doing it in two lines to make it easy for viewers to understand.
            left = ProcessInfixAndAdvance(left);
        }
        return left;
}
```
```ProcessPrimaryExpAndAdvance()``` Will process the current token we are at and determine it's precedence level using the "Precedence" dictionary we created earlier. <br>
This function is a recursive function that calls parse function when it needs to parse the sub-expression such as in
```a*(b+c)``` we need to first resolve ```b+c``` then we the ```a*...```. <br>
There's a lot more to it. I recommend looking at the code to understand it better. I tried to comment it verbosely to help myself and other viewers who are visiting to check it out. <br>


