# KukuLang Parser
Parser is probably the most complicated piece of code to write in frontend section. <br>
A parsers job is to iterate the tokens generated by Lexer and turn them into valid statements or expressions that makes sense syntax wise and grammer wise. <br>
You would need to generally have to generate an AST or Parse tree followed by a semantic analysis to make sure that the code makes sense but in my case this was not necessary (as far as I have noticed). <br>

Incase anyone is interested in the grammer here it is 
```grammer
Program         ::= { Statement }
Statement       ::= DefineType | SetStatement | DefineFunction | WhileLoop | IfStatement | PrintStatement | ReturnStatement

DefineType      ::= "define" Identifier "with" FieldList ";"
FieldList       ::= Field { "," Field }
Field           ::= Identifier "(" Type ")"
Type            ::= "int" | "string" | Identifier

SetStatement    ::= "set" Identifier "to" Expression ";"
Expression      ::= Literal | Identifier | FunctionCall | BinaryExpression | UnaryExpression | NestedExpression
Literal         ::= IntegerLiteral | StringLiteral
IntegerLiteral  ::= [0-9]+
StringLiteral   ::= "\"" .*? "\""

FunctionCall    ::= Identifier "with" ParameterList
ParameterList   ::= Parameter { "," Parameter }
Parameter       ::= Identifier "(" Expression ")"

BinaryExpression::= Expression BinaryOperator Expression
BinaryOperator  ::= "+" | "-" | "*" | "/" | "is"
UnaryExpression ::= UnaryOperator Expression
UnaryOperator   ::= "-"
NestedExpression::= "(" Expression ")"

DefineFunction  ::= "define" Identifier "returning" Type "with" ParameterList "{" StatementList "}"
StatementList   ::= { Statement }
ParameterList   ::= Parameter { "," Parameter }
Parameter       ::= Identifier "(" Type ")"

WhileLoop       ::= "as_long_as" Expression "repeat" "{" StatementList "}"

IfStatement     ::= "if" Expression "then" "{" StatementList "}" [ "else" "{" StatementList "}" ]

PrintStatement  ::= "print" "with" Expression ";"
ReturnStatement ::= "return" [ Expression ] ";"

Identifier      ::= [a-zA-Z_][a-zA-Z0-9_]*

InputStatement  ::= "input"

ComplexExpression ::= "(" Expression ")" { BinaryOperator Expression }

```

## Statements and expressions
Statements are instructions.
```
set a to 12;
```
Expressions are statements but they have a return value (In my case we sometimes may not have a return value);
```
set human's age to 12;
```
Here, ```human's age``` is an expression as it returns a reference to age variable of human. <br>
Another example would be
```
set a to 12+2*1;
```
Here, ```a``` and ```12+2*1``` would be an expression.

## Scopes
We also have scopes which is used for defining scope level tasks, types, variables and memory management. A scope is a class which can hold all the custom types and tasks defined in that scope, variables created in that scope and a reference to it's parent. <br>
It also has functions to create/update variables in the current scope or parent scope and to access defined tasks or types in current or parent scopes.



## Parsing Algorithms
There are several algorithms that have its own strength and weaknesses. One of the most common algorithm is probably going to be **Recursive Descent Parser (RDP)** which is quite simply to understand but it can get very dirty and confusing because of all the recursions. <br>
I initially started off with RDP but noticed that my code was getting too complicated, especially when dealing with expressions. I researched a little bit and caught an algorithm in the wild known as **Pratt Parser Algorithm (PP)**. It took me some time to grasp the concept of Pratt Parser and I still sometimes feel like I do not know it well. But I have been able to write it from scratch based on my understanding and also extended it's functionality beyond mathematical expressions so I think I some what have decent idea. PP is an amazing algorithm which makes working with expressions very clean and easy. It uses Precedence (Priority) to determine arrangement of an expression. <br> <br>

In the end I decided to create my own simple statement evaluator which takes some element of RDP for parsing statements, <br>
Pratt Parser for evaluating Expressions.

### Simple Statement Evaluator
This evaluator reads the token and determines what kind of statemnt it is dealing it. The type of evaluations we have are :- <br>
- Define Evaluator (Defining Custom Types and Tasks)
- Set Evaluator (evaluate Set statements)
- Function Call evaluator (Evaluate independent function calls)
- If evaluator (conditional if else evaluation)
- Return Evaluator (return statement evaluation)
- Loop evaluator (Evaluates loop)
- Print Evaluator (evaluates print statements)
```c#
public static void EvaluateToken<ParserReturnType, ParserArgument>(ParserBase<ParserReturnType, ParserArgument> parser, ASTScope scope)
        {
            //Each sub-evaluate method needs to consume the . or }
            switch (parser.CurrentToken.Type)
            {
                case TokenType.Define:
                    EvaluateDefineToken(parser, scope);
                    break;
                case TokenType.Set:
                    EvaluateSetToken(parser, scope);
                    break;
                case TokenType.Identifier:
                    EvaluateFunctionCall(parser, scope);
                    break;
                case TokenType.If:
                    EvaluateIfToken(parser, scope);
                    break;
                case TokenType.Return:
                    EvaluateReturnToken(parser, scope);
                    break;
                case TokenType.Until:
                    EvaluateLoopToken(parser, scope);
                    break;
                case TokenType.AsLongAs:
                    EvaluateLoopToken(parser, scope);
                    break;
                case TokenType.Print:
                    EvaluatePrint(parser, scope);
                    break;
                default:
                    throw new UnknownTokenException(parser.CurrentToken);
            }
        }
```
#### Define Evaluator
Example of define statements
```
Define Human with age(int);
Define Square returning float with num(int){
    return num*num;
}
```
Its grammatical structure is <br>
"Define" identifier with properties/arguments. <br>
```pseudo
if currentToken == returning {
    //it is a task definition

    //note down its return type
    //validate if the type exist in current or parent scope
    //int float text char bool exist by default
    //proceed to with and then store all the arguments
    //Create it's CustomTask Object and store it in scope's definedTask variable
}
else if currentToken == with{
    //it is custom type definition

    //proceed to with and store all of its properties while validate it's type
    //Create CustomType and store it in scope's definedType variable
}
```
#### Set evaluator
Example of set statements
```
set a to 12; ~simple~
set a's b's c to foo's bar; ~nested variable~
set b to Square with num(2); ~simple b, function call~
```
It's grammatical structure is <br>
"set" single/nestedVariable to expressionStatement; <br>
single/nestedVariable and expressionStatement are both handled by pratt parser.<br> <br>
Not gonna go into detail for the rest of the evaluator, look at the source code instead.

### Pratt Parser
